# 文档

ProseMirror 定义了自己的数据结构来表示内容文档。由于文档是围绕编辑器其他部分构建的核心元素，因此了解文档的工作原理很有帮助。

## 结构

ProseMirror 文档是一个节点，其中包含一个包含零个或多个子节点的片段。

这很像浏览器的 DOM，因为它是递归和树形的。但它与 DOM 的不同之处在于存储内联内容的方式。

在 HTML 中，带标记的段落表示为一棵树，就像这样：

```
<p>This is <strong>strong text with <em>emphasis</em></strong></p>
```

而在 ProseMirror 中，内联内容被建模为扁平序列，标记作为元数据附在节点上：

这更符合我们思考和处理此类文本的方式。它允许我们使用字符偏移量来表示段落中的位置，而不是树状结构中的路径，这样就能更轻松地执行拆分或更改内容样式等操作，而无需执行笨拙的树状结构操作。

这也意味着每个文档只有一个有效的表示法。具有相同标记集的相邻文本节点总是组合在一起，不允许出现空文本节点。标记出现的顺序由模式规定。

因此，ProseMirror 文档是一棵由块节点组成的树，其中大部分叶节点都是文本块，即包含文本的块节点。叶块节点也可以是空的，例如`hr`或`video`元素。

节点对象具有许多属性，这些属性反映了节点对象在文档中所扮演的角色：

- `isBlock` 和 `isInline` 会告诉你给定的节点是块节点还是内联节点。
- `inlineContent`（内联内容）对于希望将内联节点作为内容的节点为 `true`。
- 对于具有内联内容的块状节点，`isTextblock` 为 `true`。
- `isLeaf` 表示节点不允许任何内容。

因此，一个典型的 `paragraph` 节点将是一个文本块，而一个 `blockquote` 可能是一个内容由其他块组成的块元素。文本、硬分隔符和内联图片是内联叶节点，而`hr`节点则是块叶节点的一个例子。

[模式]()允许对可能出现的内容指定更精确的限制--例如，即使节点允许块内容，也不意味着它允许所有块节点作为内容。

## 身份标识和持久性

DOM 树与 ProseMirror 文档的另一个重要区别在于代表节点对象的行为方式。在 DOM 中，节点是具有身份标识的可变对象，这意味着一个节点只能出现在一个父节点中，而且节点对象在更新时会发生变化。

而在 ProseMirror 中，节点只是一个简单的值，应该像对待代表数字 3 的值一样来对待它。3 可以同时出现在多个数据结构中，它与当前所在的数据结构没有父级链接，如果给它加上 1，就会得到一个新值 4，而不会改变原来的 3。

ProseMirror 文档的片段也是如此。它们不会改变，但可以用作计算修改后文档片段的起始值。它们不知道自己属于哪个数据结构，但可以是多个结构的一部分，甚至可以在一个结构中出现多次。它们是值，而不是有状态的对象。

这意味着每次更新文档时，都会得到一个新的文档值。该文档值将与原始文档值共享所有未发生变化的子节点，因此创建成本相对较低。

这样做有很多好处。它使编辑器在更新期间不可能处于无效的中间状态，因为新的状态和新的文档可以即时交换。它还能让我们更轻松地以某种数学方式推理文档，而如果你的值在你的脚下不断变化，那就真的很难了。这有助于使协作编辑成为可能，并允许 ProseMirror 通过比较最后绘制到屏幕上的文档和当前文档，运行非常高效的 DOM 更新算法。

由于这些节点是由普通 JavaScript 对象表示的，明确冻结其属性会影响性能，因此实际上可以更改它们。但这样做是不被支持的，而且会导致程序崩溃，因为它们几乎总是在多个数据结构之间共享。所以一定要小心！请注意，这同样适用于作为节点对象一部分的数组和普通对象，例如用于存储节点属性的对象或片段中的子节点数组。

## 数据结构

文档的对象结构如下所示：

每个节点都由`Node`类的一个实例来表示。它被标记为一个`类型`，该`类型`知道节点的名称、对其有效的属性等。`Node`类型（和`Mark`类型）在每个模式中创建一次，并知道它们属于哪个模式。

节点的内容存储在 `Fragment` 的一个实例中，该实例包含一个节点序列。即使是没有内容或不允许有内容的节点，这个字段也会被填充（使用共享的空片段）。

有些节点类型允许使用属性，即存储在每个节点中的额外值。例如，`image`节点可以使用这些属性来存储其 alt 文本和 URL。

此外，`inline`节点还包含一组激活状态的标记--例如 `emphasis` 或 `link`--这些标记以 `Mark` 实例数组的形式表示。

完整的文档只是一个节点。文档内容表现为顶层节点的子节点。通常，它包含一系列块节点，其中一些可能是包含内联内容的文本块。但顶层节点本身也可能是一个文本块，因此文档只包含内联内容。

文档的模式决定了允许在哪里创建哪种节点。要以编程方式创建节点，必须通过`模式`，例如使用`node`和`text`方法。

```
import {schema} from "prosemirror-schema-basic"

// (The null arguments are where you can specify attributes, if necessary.)
let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("One.")]),
  schema.node("horizontal_rule"),
  schema.node("paragraph", null, [schema.text("Two!")])
])
```

## 索引

ProseMirror 节点支持两种类型的索引--可以把它们当作树来处理，使用偏移到单个节点；也可以把它们当作扁平的标记序列来处理。

第一种方法允许你做与 DOM 类似的事情--与单个节点交互、使用 `child` 方法和 `childCount` 直接访问子节点、编写扫描文档的递归函数（如果只想查看所有节点，可使用 `descendants` 或 `nodesBetween`）。

第二种方法在处理文档中的特定位置时更有用。它允许将文档中的任何位置表示为一个整数，即标记序列中的索引。这些标记实际上并不作为对象存在于内存中--它们只是一种计数约定，但文档的树形结构，以及每个节点都知道自己的大小，这也使得按位置访问的成本很低。

- 文档的起始位置，即第一个内容之前的位置为 0。
- 进入或离开一个非叶节点的节点算作一个标记。因此，如果文档以一个段落开始，则该段落的起点算作位置 1。
- 文本节点中的每个字符都算一个标记。因此，如果文档开头的段落包含单词 "hi"，那么位置 2 在 "h "之后，位置 3 在 "i "之后，位置 4 在整个段落之后。
- 不允许包含内容（如图片）的叶节点也算作一个标记。

因此，如果你有一个文档，用 HTML 表示时，看起来是这样的：

```
<p>One</p>
<blockquote><p>Two<img src="..."></p></blockquote>
```

标记序列的位置如下所示：

```
0   1 2 3 4    5
 <p> O n e </p>

5            6   7 8 9 10    11   12            13
 <blockquote> <p> T w o <img> </p> </blockquote>
```

每个节点都有一个 `nodeSize` 属性，可提供整个节点的大小，你还可以访问 `.content.size` 来获取节点内容的大小。请注意，对于外层文档节点，打开和关闭标记不被视为文档的一部分（因为你无法将光标置于文档之外），因此文档的大小是 `doc.content.size` 而不是 `doc.nodeSize`。

手动解释这些位置需要进行大量的计算。你可以调用 `Node.resolve`，为位置获取描述性更强的数据结构。该数据结构会告诉你该位置的父节点是什么、它在父节点中的偏移量是多少、父节点有哪些祖节点以及其他一些信息。

注意区分子索引（根据 `childCount`）、整个文档的位置和节点本地偏移（有时在递归函数中用于表示当前正在处理的节点的位置）。

## 切片

为了处理复制、粘贴和拖放等操作，有必要讨论文档片段，即两个位置之间的内容。这种片段与完整节点或片段的不同之处在于，其起点或终点的部分节点可能是 "打开 "的。

例如，如果你从一个段落的中间选择到下一个段落的中间，那么你选择的片段中有两个段落，第一个段落的开头是开放的，第二个段落的结尾是开放的，而如果你节点选择一个段落，那么你选择的是一个封闭的节点。如果把这种开放节点中的内容当作节点的全部内容来处理，可能会违反模式约束，因为有些所需的节点落在了切片之外。

`切片`数据结构用于表示这种片段。它存储一个片段以及两侧的开放深度。您可以使用节点上的切片方法从文档中切出一个片段。

```
// doc holds two paragraphs, containing text "a" and "b"
let slice1 = doc.slice(0, 3) // The first paragraph
console.log(slice1.openStart, slice1.openEnd) // → 0 0
let slice2 = doc.slice(1, 5) // From start of first paragraph
                             // to end of second
console.log(slice2.openStart, slice2.openEnd) // → 1 1
```

## 更新

由于节点和片段是持久性的，因此你永远都不应该更改它们。如果你有一个指向文档（或节点或片段）的句柄，该对象将保持不变。

大多数情况下，你会使用[转换]()来更新文档，而不必直接接触节点。这些[转换]()还会留下更改记录，这在文档是编辑器状态时是必要的。

如果你想手动派生一个更新文档，节点和片段类型上有一些辅助方法。要创建整个文档的更新版本，通常需要使用 `Node.replace`，它可以用新内容片段替换文档的给定范围。要浅层更新节点，可以使用节点的复制方法，用新内容创建一个类似的节点。片段也有各种更新方法，如 `replaceChild` 或 `append`。
